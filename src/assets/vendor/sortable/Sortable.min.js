/* ! Sortable 1.13.0 - MIT | git://github.com/SortableJS/Sortable.git */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : (t = t || self).Sortable = e() }(this, function () { 'use strict'; function o(t) { return (o = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t })(t) } function a() { return (a = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const o in n)Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]) } return t }).apply(this, arguments) } function I(i) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; let e = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (e = e.concat(Object.getOwnPropertySymbols(r).filter(function (t) { return Object.getOwnPropertyDescriptor(r, t).enumerable }))), e.forEach(function (t) { let e, n, o; e = i, o = r[n = t], n in e ? Object.defineProperty(e, n, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = o }) } return i } function l(t, e) { if (t == null) return {}; let n; let o; const i = (function (t, e) { if (t == null) return {}; let n; let o; const i = {}; const r = Object.keys(t); for (o = 0; o < r.length; o++)n = r[o], e.indexOf(n) >= 0 || (i[n] = t[n]); return i }(t, e)); if (Object.getOwnPropertySymbols) { const r = Object.getOwnPropertySymbols(t); for (o = 0; o < r.length; o++)n = r[o], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n]) } return i } function e(t) { return (function (t) { if (Array.isArray(t)) { for (var e = 0, n = new Array(t.length); e < t.length; e++)n[e] = t[e]; return n } }(t)) || (function (t) { if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]') return Array.from(t) }(t)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance') }()) } function t(t) { if (typeof window !== 'undefined' && window.navigator) return !!navigator.userAgent.match(t) } const w = t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i); const E = t(/Edge/i); const c = t(/firefox/i); const u = t(/safari/i) && !t(/chrome/i) && !t(/android/i); const n = t(/iP(ad|od|hone)/i); const i = t(/chrome/i) && t(/android/i); const r = { capture: !1, passive: !1 }; function d(t, e, n) { t.addEventListener(e, n, !w && r) } function s(t, e, n) { t.removeEventListener(e, n, !w && r) } function h(t, e) { if (e) { if (e[0] === '>' && (e = e.substring(1)), t) try { if (t.matches) return t.matches(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e) } catch (t) { return !1 } return !1 } } function P(t, e, n, o) { if (t) { n = n || document; do { if (e != null && (e[0] === '>' ? t.parentNode === n && h(t, e) : h(t, e)) || o && t === n) return t; if (t === n) break } while (t = (i = t).host && i !== document && i.host.nodeType ? i.host : i.parentNode) } let i; return null } let f; const p = /\s+/g; function k(t, e, n) { if (t && e) if (t.classList)t.classList[n ? 'add' : 'remove'](e); else { const o = (' ' + t.className + ' ').replace(p, ' ').replace(' ' + e + ' ', ' '); t.className = (o + (n ? ' ' + e : '')).replace(p, ' ') } } function R(t, e, n) { const o = t && t.style; if (o) { if (void 0 === n) return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, '') : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e]; e in o || e.indexOf('webkit') !== -1 || (e = '-webkit-' + e), o[e] = n + (typeof n === 'string' ? '' : 'px') } } function v(t, e) { let n = ''; if (typeof t === 'string')n = t; else do { const o = R(t, 'transform'); o && o !== 'none' && (n = o + ' ' + n) } while (!e && (t = t.parentNode)); const i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix; return i && new i(n) } function g(t, e, n) { if (t) { const o = t.getElementsByTagName(e); let i = 0; const r = o.length; if (n) for (;i < r; i++)n(o[i], i); return o } return [] } function A() { const t = document.scrollingElement; return t || document.documentElement } function X(t, e, n, o, i) { if (t.getBoundingClientRect || t === window) { let r, a, l, s, c, u, d; if (d = t !== window && t.parentNode && t !== A() ? (a = (r = t.getBoundingClientRect()).top, l = r.left, s = r.bottom, c = r.right, u = r.height, r.width) : (l = a = 0, s = window.innerHeight, c = window.innerWidth, u = window.innerHeight, window.innerWidth), (e || n) && t !== window && (i = i || t.parentNode, !w)) do { if (i && i.getBoundingClientRect && (R(i, 'transform') !== 'none' || n && R(i, 'position') !== 'static')) { const h = i.getBoundingClientRect(); a -= h.top + parseInt(R(i, 'border-top-width')), l -= h.left + parseInt(R(i, 'border-left-width')), s = a + r.height, c = l + r.width; break } } while (i = i.parentNode); if (o && t !== window) { const f = v(i || t); const p = f && f.a; const g = f && f.d; f && (s = (a /= g) + (u /= g), c = (l /= p) + (d /= p)) } return { top: a, left: l, bottom: s, right: c, width: d, height: u } } } function Y(t, e, n) { for (let o = H(t, !0), i = X(t)[e]; o;) { const r = X(o)[n]; if (!(n === 'top' || n === 'left' ? r <= i : i <= r)) return o; if (o === A()) break; o = H(o, !1) } return !1 } function m(t, e, n) { for (let o = 0, i = 0, r = t.children; i < r.length;) { if (r[i].style.display !== 'none' && r[i] !== Rt.ghost && r[i] !== Rt.dragged && P(r[i], n.draggable, t, !1)) { if (o === e) return r[i]; o++ }i++ } return null } function B(t, e) { for (var n = t.lastElementChild; n && (n === Rt.ghost || R(n, 'display') === 'none' || e && !h(n, e));)n = n.previousElementSibling; return n || null } function F(t, e) { let n = 0; if (!t || !t.parentNode) return -1; for (;t = t.previousElementSibling;)t.nodeName.toUpperCase() === 'TEMPLATE' || t === Rt.clone || e && !h(t, e) || n++; return n } function b(t) { let e = 0; let n = 0; const o = A(); if (t) do { const i = v(t); const r = i.a; const a = i.d; e += t.scrollLeft * r, n += t.scrollTop * a } while (t !== o && (t = t.parentNode)); return [e, n] } function H(t, e) { if (!t || !t.getBoundingClientRect) return A(); let n = t; let o = !1; do { if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) { const i = R(n); if (n.clientWidth < n.scrollWidth && (i.overflowX == 'auto' || i.overflowX == 'scroll') || n.clientHeight < n.scrollHeight && (i.overflowY == 'auto' || i.overflowY == 'scroll')) { if (!n.getBoundingClientRect || n === document.body) return A(); if (o || e) return n; o = !0 } } } while (n = n.parentNode); return A() } function y(t, e) { return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width) } function D(e, n) { return function () { if (!f) { const t = arguments; t.length === 1 ? e.call(this, t[0]) : e.apply(this, t), f = setTimeout(function () { f = void 0 }, n) } } } function L(t, e, n) { t.scrollLeft += e, t.scrollTop += n } function S(t) { const e = window.Polymer; const n = window.jQuery || window.Zepto; return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0) } function _(t, e) { R(t, 'position', 'absolute'), R(t, 'top', e.top), R(t, 'left', e.left), R(t, 'width', e.width), R(t, 'height', e.height) } function C(t) { R(t, 'position', ''), R(t, 'top', ''), R(t, 'left', ''), R(t, 'width', ''), R(t, 'height', '') } const j = 'Sortable' + (new Date()).getTime(); function T() { let e; let o = []; return { captureAnimationState: function () { o = [], this.options.animation && [].slice.call(this.el.children).forEach(function (t) { if (R(t, 'display') !== 'none' && t !== Rt.ghost) { o.push({ target: t, rect: X(t) }); const e = I({}, o[o.length - 1].rect); if (t.thisAnimationDuration) { const n = v(t, !0); n && (e.top -= n.f, e.left -= n.e) }t.fromRect = e } }) }, addAnimationState: function (t) { o.push(t) }, removeAnimationState: function (t) { o.splice((function (t, e) { for (const n in t) if (t.hasOwnProperty(n)) for (const o in e) if (e.hasOwnProperty(o) && e[o] === t[n][o]) return Number(n); return -1 }(o, { target: t })), 1) }, animateAll: function (t) { const c = this; if (!this.options.animation) return clearTimeout(e), void (typeof t === 'function' && t()); let u = !1; let d = 0; o.forEach(function (t) { let e = 0; const n = t.target; const o = n.fromRect; const i = X(n); const r = n.prevFromRect; const a = n.prevToRect; const l = t.rect; const s = v(n, !0); s && (i.top -= s.f, i.left -= s.e), n.toRect = i, n.thisAnimationDuration && y(r, i) && !y(o, i) && (l.top - i.top) / (l.left - i.left) == (o.top - i.top) / (o.left - i.left) && (e = (function (t, e, n, o) { return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * o.animation }(l, r, a, c.options))), y(i, o) || (n.prevFromRect = o, n.prevToRect = i, e || (e = c.options.animation), c.animate(n, l, i, e)), e && (u = !0, d = Math.max(d, e), clearTimeout(n.animationResetTimer), n.animationResetTimer = setTimeout(function () { n.animationTime = 0, n.prevFromRect = null, n.fromRect = null, n.prevToRect = null, n.thisAnimationDuration = null }, e), n.thisAnimationDuration = e) }), clearTimeout(e), u ? e = setTimeout(function () { typeof t === 'function' && t() }, d) : typeof t === 'function' && t(), o = [] }, animate: function (t, e, n, o) { if (o) { R(t, 'transition', ''), R(t, 'transform', ''); const i = v(this.el); const r = i && i.a; const a = i && i.d; const l = (e.left - n.left) / (r || 1); const s = (e.top - n.top) / (a || 1); t.animatingX = !!l, t.animatingY = !!s, R(t, 'transform', 'translate3d(' + l + 'px,' + s + 'px,0)'), this.forRepaintDummy = (function (t) { return t.offsetWidth }(t)), R(t, 'transition', 'transform ' + o + 'ms' + (this.options.easing ? ' ' + this.options.easing : '')), R(t, 'transform', 'translate3d(0,0,0)'), typeof t.animated === 'number' && clearTimeout(t.animated), t.animated = setTimeout(function () { R(t, 'transition', ''), R(t, 'transform', ''), t.animated = !1, t.animatingX = !1, t.animatingY = !1 }, o) } } } } const x = []; const M = { initializeByDefault: !0 }; const O = { mount: function (e) { for (const t in M)!M.hasOwnProperty(t) || t in e || (e[t] = M[t]); x.forEach(function (t) { if (t.pluginName === e.pluginName) throw 'Sortable: Cannot mount plugin '.concat(e.pluginName, ' more than once') }), x.push(e) }, pluginEvent: function (e, n, o) { const t = this; this.eventCanceled = !1, o.cancel = function () { t.eventCanceled = !0 }; const i = e + 'Global'; x.forEach(function (t) { n[t.pluginName] && (n[t.pluginName][i] && n[t.pluginName][i](I({ sortable: n }, o)), n.options[t.pluginName] && n[t.pluginName][e] && n[t.pluginName][e](I({ sortable: n }, o))) }) }, initializePlugins: function (o, i, r, t) { for (const e in x.forEach(function (t) { const e = t.pluginName; if (o.options[e] || t.initializeByDefault) { const n = new t(o, i, o.options); n.sortable = o, n.options = o.options, o[e] = n, a(r, n.defaults) } }), o.options) if (o.options.hasOwnProperty(e)) { const n = this.modifyOption(o, e, o.options[e]); void 0 !== n && (o.options[e] = n) } }, getEventProperties: function (e, n) { const o = {}; return x.forEach(function (t) { typeof t.eventProperties === 'function' && a(o, t.eventProperties.call(n[t.pluginName], e)) }), o }, modifyOption: function (e, n, o) { let i; return x.forEach(function (t) { e[t.pluginName] && t.optionListeners && typeof t.optionListeners[n] === 'function' && (i = t.optionListeners[n].call(e[t.pluginName], o)) }), i } }; function N(t) { let e = t.sortable; const n = t.rootEl; const o = t.name; const i = t.targetEl; const r = t.cloneEl; const a = t.toEl; const l = t.fromEl; const s = t.oldIndex; const c = t.newIndex; const u = t.oldDraggableIndex; const d = t.newDraggableIndex; const h = t.originalEvent; const f = t.putSortable; const p = t.extraEventProperties; if (e = e || n && n[j]) { let g; const v = e.options; const m = 'on' + o.charAt(0).toUpperCase() + o.substr(1); !window.CustomEvent || w || E ? (g = document.createEvent('Event')).initEvent(o, !0, !0) : g = new CustomEvent(o, { bubbles: !0, cancelable: !0 }), g.to = a || n, g.from = l || n, g.item = i || n, g.clone = r, g.oldIndex = s, g.newIndex = c, g.oldDraggableIndex = u, g.newDraggableIndex = d, g.originalEvent = h, g.pullMode = f ? f.lastPutMode : void 0; const b = I({}, p, O.getEventProperties(o, e)); for (const y in b)g[y] = b[y]; n && n.dispatchEvent(g), v[m] && v[m].call(e, g) } } function K(t, e, n) { const o = arguments.length > 2 && void 0 !== n ? n : {}; const i = o.evt; const r = l(o, ['evt']); O.pluginEvent.bind(Rt)(t, e, I({ dragEl: z, parentEl: G, ghostEl: U, rootEl: q, nextEl: V, lastDownEl: Z, cloneEl: Q, cloneHidden: $, dragStarted: dt, putSortable: it, activeSortable: Rt.active, originalEvent: i, oldIndex: J, oldDraggableIndex: et, newIndex: tt, newDraggableIndex: nt, hideGhostForTarget: At, unhideGhostForTarget: It, cloneNowHidden: function () { $ = !0 }, cloneNowShown: function () { $ = !1 }, dispatchSortableEvent: function (t) { W({ sortable: e, name: t, originalEvent: i }) } }, r)) } function W(t) { N(I({ putSortable: it, cloneEl: Q, targetEl: z, rootEl: q, oldIndex: J, oldDraggableIndex: et, newIndex: tt, newDraggableIndex: nt }, t)) } let z; let G; let U; let q; let V; let Z; let Q; let $; let J; let tt; let et; let nt; let ot; let it; let rt; let at; let lt; let st; let ct; let ut; let dt; let ht; let ft; let pt; let gt; let vt = !1; let mt = !1; const bt = []; let yt = !1; let wt = !1; let Et = []; let Dt = !1; const St = []; const _t = typeof document !== 'undefined'; const Ct = n; const Tt = E || w ? 'cssFloat' : 'float'; const xt = _t && !i && !n && 'draggable' in document.createElement('div'); const Mt = (function () { if (_t) { if (w) return !1; const t = document.createElement('x'); return t.style.cssText = 'pointer-events:auto', t.style.pointerEvents === 'auto' } }()); const Ot = function (t, e) { const n = R(t); const o = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth); const i = m(t, 0, e); const r = m(t, 1, e); const a = i && R(i); const l = r && R(r); const s = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + X(i).width; const c = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + X(r).width; if (n.display === 'flex') return n.flexDirection === 'column' || n.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal'; if (n.display === 'grid') return n.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal'; if (i && a.float && a.float !== 'none') { const u = a.float === 'left' ? 'left' : 'right'; return !r || l.clear !== 'both' && l.clear !== u ? 'horizontal' : 'vertical' } return i && (a.display === 'block' || a.display === 'flex' || a.display === 'table' || a.display === 'grid' || o <= s && n[Tt] === 'none' || r && n[Tt] === 'none' && o < s + c) ? 'vertical' : 'horizontal' }; const Nt = function (t) { function s(a, l) { return function (t, e, n, o) { const i = t.options.group.name && e.options.group.name && t.options.group.name === e.options.group.name; if (a == null && (l || i)) return !0; if (a == null || !1 === a) return !1; if (l && a === 'clone') return a; if (typeof a === 'function') return s(a(t, e, n, o), l)(t, e, n, o); const r = (l ? t : e).options.group.name; return !0 === a || typeof a === 'string' && a === r || a.join && a.indexOf(r) > -1 } } const e = {}; let n = t.group; n && o(n) == 'object' || (n = { name: n }), e.name = n.name, e.checkPull = s(n.pull, !0), e.checkPut = s(n.put), e.revertClone = n.revertClone, t.group = e }; var At = function () { !Mt && U && R(U, 'display', 'none') }; var It = function () { !Mt && U && R(U, 'display', '') }; _t && document.addEventListener('click', function (t) { if (mt) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), mt = !1 }, !0); function Pt(t) { if (z) { const e = (function (r, a) { let l; return bt.some(function (t) { if (!B(t)) { const e = X(t); const n = t[j].options.emptyInsertThreshold; const o = r >= e.left - n && r <= e.right + n; const i = a >= e.top - n && a <= e.bottom + n; return n && o && i ? l = t : void 0 } }), l }((t = t.touches ? t.touches[0] : t).clientX, t.clientY)); if (e) { const n = {}; for (const o in t)t.hasOwnProperty(o) && (n[o] = t[o]); n.target = n.rootEl = e, n.preventDefault = void 0, n.stopPropagation = void 0, e[j]._onDragOver(n) } } } function kt(t) { z && z.parentNode[j]._isOutsideThisEl(t.target) } function Rt(t, e) { if (!t || !t.nodeType || t.nodeType !== 1) throw 'Sortable: `el` must be an HTMLElement, not '.concat({}.toString.call(t)); this.el = t, this.options = e = a({}, e), t[j] = this; const n = { group: null, sort: !0, disabled: !1, store: null, handle: null, draggable: /^[uo]l$/i.test(t.nodeName) ? '>li' : '>*', swapThreshold: 1, invertSwap: !1, invertedSwapThreshold: null, removeCloneOnHide: !0, direction: function () { return Ot(t, this.options) }, ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen', dragClass: 'sortable-drag', ignore: 'a, img', filter: null, preventOnFilter: !0, animation: 0, easing: null, setData: function (t, e) { t.setData('Text', e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: 'data-id', delay: 0, delayOnTouchOnly: !1, touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1, forceFallback: !1, fallbackClass: 'sortable-fallback', fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: !1 !== Rt.supportPointer && 'PointerEvent' in window && !u, emptyInsertThreshold: 5 }; for (const o in O.initializePlugins(this, t, n), n)o in e || (e[o] = n[o]); for (const i in Nt(e), this)i.charAt(0) === '_' && typeof this[i] === 'function' && (this[i] = this[i].bind(this)); this.nativeDraggable = !e.forceFallback && xt, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? d(t, 'pointerdown', this._onTapStart) : (d(t, 'mousedown', this._onTapStart), d(t, 'touchstart', this._onTapStart)), this.nativeDraggable && (d(t, 'dragover', this), d(t, 'dragenter', this)), bt.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), a(this, T()) } function Xt(t, e, n, o, i, r, a, l) { let s; let c; const u = t[j]; const d = u.options.onMove; return !window.CustomEvent || w || E ? (s = document.createEvent('Event')).initEvent('move', !0, !0) : s = new CustomEvent('move', { bubbles: !0, cancelable: !0 }), s.to = e, s.from = t, s.dragged = n, s.draggedRect = o, s.related = i || e, s.relatedRect = r || X(e), s.willInsertAfter = l, s.originalEvent = a, t.dispatchEvent(s), d && (c = d.call(u, s, a)), c } function Yt(t) { t.draggable = !1 } function Bt() { Dt = !1 } function Ft(t) { for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; n--;)o += e.charCodeAt(n); return o.toString(36) } function Ht(t) { return setTimeout(t, 0) } function Lt(t) { return clearTimeout(t) }Rt.prototype = { constructor: Rt, _isOutsideThisEl: function (t) { this.el.contains(t) || t === this.el || (ht = null) }, _getDirection: function (t, e) { return typeof this.options.direction === 'function' ? this.options.direction.call(this, t, e, z) : this.options.direction }, _onTapStart: function (e) { if (e.cancelable) { const n = this; const o = this.el; const t = this.options; const i = t.preventOnFilter; const r = e.type; const a = e.touches && e.touches[0] || e.pointerType && e.pointerType === 'touch' && e; let l = (a || e).target; const s = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l; let c = t.filter; if ((function (t) { St.length = 0; const e = t.getElementsByTagName('input'); let n = e.length; for (;n--;) { const o = e[n]; o.checked && St.push(o) } }(o)), !z && !(/mousedown|pointerdown/.test(r) && e.button !== 0 || t.disabled) && !s.isContentEditable && (this.nativeDraggable || !u || !l || l.tagName.toUpperCase() !== 'SELECT') && !((l = P(l, t.draggable, o, !1)) && l.animated || Z === l)) { if (J = F(l), et = F(l, t.draggable), typeof c === 'function') { if (c.call(this, e, l, this)) return W({ sortable: n, rootEl: s, name: 'filter', targetEl: l, toEl: o, fromEl: o }), K('filter', n, { evt: e }), void (i && e.cancelable && e.preventDefault()) } else if (c && (c = c.split(',').some(function (t) { if (t = P(s, t.trim(), o, !1)) return W({ sortable: n, rootEl: t, name: 'filter', targetEl: l, fromEl: o, toEl: o }), K('filter', n, { evt: e }), !0 }))) return void (i && e.cancelable && e.preventDefault()); t.handle && !P(s, t.handle, o, !1) || this._prepareDragStart(e, a, l) } } }, _prepareDragStart: function (t, e, n) { let o; const i = this; const r = i.el; const a = i.options; const l = r.ownerDocument; if (n && !z && n.parentNode === r) { const s = X(n); if (q = r, G = (z = n).parentNode, V = z.nextSibling, Z = n, ot = a.group, rt = { target: Rt.dragged = z, clientX: (e || t).clientX, clientY: (e || t).clientY }, ct = rt.clientX - s.left, ut = rt.clientY - s.top, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, z.style['will-change'] = 'all', o = function () { K('delayEnded', i, { evt: t }), Rt.eventCanceled ? i._onDrop() : (i._disableDelayedDragEvents(), !c && i.nativeDraggable && (z.draggable = !0), i._triggerDragStart(t, e), W({ sortable: i, name: 'choose', originalEvent: t }), k(z, a.chosenClass, !0)) }, a.ignore.split(',').forEach(function (t) { g(z, t.trim(), Yt) }), d(l, 'dragover', Pt), d(l, 'mousemove', Pt), d(l, 'touchmove', Pt), d(l, 'mouseup', i._onDrop), d(l, 'touchend', i._onDrop), d(l, 'touchcancel', i._onDrop), c && this.nativeDraggable && (this.options.touchStartThreshold = 4, z.draggable = !0), K('delayStart', this, { evt: t }), !a.delay || a.delayOnTouchOnly && !e || this.nativeDraggable && (E || w))o(); else { if (Rt.eventCanceled) return void this._onDrop(); d(l, 'mouseup', i._disableDelayedDrag), d(l, 'touchend', i._disableDelayedDrag), d(l, 'touchcancel', i._disableDelayedDrag), d(l, 'mousemove', i._delayedDragTouchMoveHandler), d(l, 'touchmove', i._delayedDragTouchMoveHandler), a.supportPointer && d(l, 'pointermove', i._delayedDragTouchMoveHandler), i._dragStartTimer = setTimeout(o, a.delay) } } }, _delayedDragTouchMoveHandler: function (t) { const e = t.touches ? t.touches[0] : t; Math.max(Math.abs(e.clientX - this._lastX), Math.abs(e.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag() }, _disableDelayedDrag: function () { z && Yt(z), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents() }, _disableDelayedDragEvents: function () { const t = this.el.ownerDocument; s(t, 'mouseup', this._disableDelayedDrag), s(t, 'touchend', this._disableDelayedDrag), s(t, 'touchcancel', this._disableDelayedDrag), s(t, 'mousemove', this._delayedDragTouchMoveHandler), s(t, 'touchmove', this._delayedDragTouchMoveHandler), s(t, 'pointermove', this._delayedDragTouchMoveHandler) }, _triggerDragStart: function (t, e) { e = e || t.pointerType == 'touch' && t, !this.nativeDraggable || e ? this.options.supportPointer ? d(document, 'pointermove', this._onTouchMove) : d(document, e ? 'touchmove' : 'mousemove', this._onTouchMove) : (d(z, 'dragend', this), d(q, 'dragstart', this._onDragStart)); try { document.selection ? Ht(function () { document.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) {} }, _dragStarted: function (t, e) { if (vt = !1, q && z) { K('dragStarted', this, { evt: e }), this.nativeDraggable && d(document, 'dragover', kt); const n = this.options; t || k(z, n.dragClass, !1), k(z, n.ghostClass, !0), Rt.active = this, t && this._appendGhost(), W({ sortable: this, name: 'start', originalEvent: e }) } else this._nulling() }, _emulateDragOver: function () { if (at) { this._lastX = at.clientX, this._lastY = at.clientY, At(); for (var t = document.elementFromPoint(at.clientX, at.clientY), e = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(at.clientX, at.clientY)) !== e;)e = t; if (z.parentNode[j]._isOutsideThisEl(t), e) do { if (e[j]) { if (e[j]._onDragOver({ clientX: at.clientX, clientY: at.clientY, target: t, rootEl: e }) && !this.options.dragoverBubble) break }t = e } while (e = e.parentNode); It() } }, _onTouchMove: function (t) { if (rt) { const e = this.options; const n = e.fallbackTolerance; const o = e.fallbackOffset; const i = t.touches ? t.touches[0] : t; let r = U && v(U, !0); const a = U && r && r.a; const l = U && r && r.d; const s = Ct && gt && b(gt); const c = (i.clientX - rt.clientX + o.x) / (a || 1) + (s ? s[0] - Et[0] : 0) / (a || 1); const u = (i.clientY - rt.clientY + o.y) / (l || 1) + (s ? s[1] - Et[1] : 0) / (l || 1); if (!Rt.active && !vt) { if (n && Math.max(Math.abs(i.clientX - this._lastX), Math.abs(i.clientY - this._lastY)) < n) return; this._onDragStart(t, !0) } if (U) { r ? (r.e += c - (lt || 0), r.f += u - (st || 0)) : r = { a: 1, b: 0, c: 0, d: 1, e: c, f: u }; const d = 'matrix('.concat(r.a, ',').concat(r.b, ',').concat(r.c, ',').concat(r.d, ',').concat(r.e, ',').concat(r.f, ')'); R(U, 'webkitTransform', d), R(U, 'mozTransform', d), R(U, 'msTransform', d), R(U, 'transform', d), lt = c, st = u, at = i }t.cancelable && t.preventDefault() } }, _appendGhost: function () { if (!U) { const t = this.options.fallbackOnBody ? document.body : q; const e = X(z, !0, Ct, !0, t); const n = this.options; if (Ct) { for (gt = t; R(gt, 'position') === 'static' && R(gt, 'transform') === 'none' && gt !== document;)gt = gt.parentNode; gt !== document.body && gt !== document.documentElement ? (gt === document && (gt = A()), e.top += gt.scrollTop, e.left += gt.scrollLeft) : gt = A(), Et = b(gt) }k(U = z.cloneNode(!0), n.ghostClass, !1), k(U, n.fallbackClass, !0), k(U, n.dragClass, !0), R(U, 'transition', ''), R(U, 'transform', ''), R(U, 'box-sizing', 'border-box'), R(U, 'margin', 0), R(U, 'top', e.top), R(U, 'left', e.left), R(U, 'width', e.width), R(U, 'height', e.height), R(U, 'opacity', '0.8'), R(U, 'position', Ct ? 'absolute' : 'fixed'), R(U, 'zIndex', '100000'), R(U, 'pointerEvents', 'none'), Rt.ghost = U, t.appendChild(U), R(U, 'transform-origin', ct / parseInt(U.style.width) * 100 + '% ' + ut / parseInt(U.style.height) * 100 + '%') } }, _onDragStart: function (t, e) { const n = this; const o = t.dataTransfer; const i = n.options; K('dragStart', this, { evt: t }), Rt.eventCanceled ? this._onDrop() : (K('setupClone', this), Rt.eventCanceled || ((Q = S(z)).draggable = !1, Q.style['will-change'] = '', this._hideClone(), k(Q, this.options.chosenClass, !1), Rt.clone = Q), n.cloneId = Ht(function () { K('clone', n), Rt.eventCanceled || (n.options.removeCloneOnHide || q.insertBefore(Q, z), n._hideClone(), W({ sortable: n, name: 'clone' })) }), e || k(z, i.dragClass, !0), e ? (mt = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (s(document, 'mouseup', n._onDrop), s(document, 'touchend', n._onDrop), s(document, 'touchcancel', n._onDrop), o && (o.effectAllowed = 'move', i.setData && i.setData.call(n, o, z)), d(document, 'drop', n), R(z, 'transform', 'translateZ(0)')), vt = !0, n._dragStartId = Ht(n._dragStarted.bind(n, e, t)), d(document, 'selectstart', n), dt = !0, u && R(document.body, 'user-select', 'none')) }, _onDragOver: function (n) { let o; let i; let r; let a; const l = this.el; let s = n.target; const e = this.options; const t = e.group; const c = Rt.active; const u = ot === t; const d = e.sort; const h = it || c; const f = this; let p = !1; if (!Dt) { if (void 0 !== n.preventDefault && n.cancelable && n.preventDefault(), s = P(s, e.draggable, l, !0), M('dragOver'), Rt.eventCanceled) return p; if (z.contains(n.target) || s.animated && s.animatingX && s.animatingY || f._ignoreWhileAnimating === s) return N(!1); if (mt = !1, c && !e.disabled && (u ? d || (r = !q.contains(z)) : it === this || (this.lastPutMode = ot.checkPull(this, c, z, n)) && t.checkPut(this, c, z, n))) { if (a = this._getDirection(n, s) === 'vertical', o = X(z), M('dragOverValid'), Rt.eventCanceled) return p; if (r) return G = q, O(), this._hideClone(), M('revert'), Rt.eventCanceled || (V ? q.insertBefore(z, V) : q.appendChild(z)), N(!0); const g = B(l, e.draggable); if (!g || (function (t, e, n) { const o = X(B(n.el, n.options.draggable)); return e ? t.clientX > o.right + 10 || t.clientX <= o.right && t.clientY > o.bottom && t.clientX >= o.left : t.clientX > o.right && t.clientY > o.top || t.clientX <= o.right && t.clientY > o.bottom + 10 }(n, a, this)) && !g.animated) { if (g === z) return N(!1); if (g && l === n.target && (s = g), s && (i = X(s)), !1 !== Xt(q, l, z, o, s, i, n, !!s)) return O(), l.appendChild(z), G = l, A(), N(!0) } else if (s.parentNode === l) { i = X(s); let v; let m; let b; const y = z.parentNode !== l; const w = !(function (t, e, n) { const o = n ? t.left : t.top; const i = n ? t.right : t.bottom; const r = n ? t.width : t.height; const a = n ? e.left : e.top; const l = n ? e.right : e.bottom; const s = n ? e.width : e.height; return o === a || i === l || o + r / 2 === a + s / 2 }(z.animated && z.toRect || o, s.animated && s.toRect || i, a)); const E = a ? 'top' : 'left'; const D = Y(s, 'top', 'top') || Y(z, 'top', 'top'); const S = D ? D.scrollTop : void 0; if (ht !== s && (m = i[E], yt = !1, wt = !w && e.invertSwap || y), (v = (function (t, e, n, o, i, r, a, l) { const s = o ? t.clientY : t.clientX; const c = o ? n.height : n.width; const u = o ? n.top : n.left; const d = o ? n.bottom : n.right; let h = !1; if (!a) if (l && pt < c * i) { if (!yt && (ft === 1 ? u + c * r / 2 < s : s < d - c * r / 2) && (yt = !0), yt)h = !0; else if (ft === 1 ? s < u + pt : d - pt < s) return -ft } else if (u + c * (1 - i) / 2 < s && s < d - c * (1 - i) / 2) return (function (t) { return F(z) < F(t) ? 1 : -1 }(e)); if ((h = h || a) && (s < u + c * r / 2 || d - c * r / 2 < s)) return u + c / 2 < s ? 1 : -1; return 0 }(n, s, i, a, w ? 1 : e.swapThreshold, e.invertedSwapThreshold == null ? e.swapThreshold : e.invertedSwapThreshold, wt, ht === s))) !== 0) for (let _ = F(z); _ -= v, (b = G.children[_]) && (R(b, 'display') === 'none' || b === U););if (v === 0 || b === s) return N(!1); ft = v; const C = (ht = s).nextElementSibling; let T = !1; const x = Xt(q, l, z, o, s, i, n, T = v === 1); if (!1 !== x) return x !== 1 && x !== -1 || (T = x === 1), Dt = !0, setTimeout(Bt, 30), O(), T && !C ? l.appendChild(z) : s.parentNode.insertBefore(z, T ? C : s), D && L(D, 0, S - D.scrollTop), G = z.parentNode, void 0 === m || wt || (pt = Math.abs(m - X(s)[E])), A(), N(!0) } if (l.contains(z)) return N(!1) } return !1 } function M(t, e) { K(t, f, I({ evt: n, isOwner: u, axis: a ? 'vertical' : 'horizontal', revert: r, dragRect: o, targetRect: i, canSort: d, fromSortable: h, target: s, completed: N, onMove: function (t, e) { return Xt(q, l, z, o, t, X(t), n, e) }, changed: A }, e)) } function O() { M('dragOverAnimationCapture'), f.captureAnimationState(), f !== h && h.captureAnimationState() } function N(t) { return M('dragOverCompleted', { insertion: t }), t && (u ? c._hideClone() : c._showClone(f), f !== h && (k(z, it ? it.options.ghostClass : c.options.ghostClass, !1), k(z, e.ghostClass, !0)), it !== f && f !== Rt.active ? it = f : f === Rt.active && it && (it = null), h === f && (f._ignoreWhileAnimating = s), f.animateAll(function () { M('dragOverAnimationComplete'), f._ignoreWhileAnimating = null }), f !== h && (h.animateAll(), h._ignoreWhileAnimating = null)), (s === z && !z.animated || s === l && !s.animated) && (ht = null), e.dragoverBubble || n.rootEl || s === document || (z.parentNode[j]._isOutsideThisEl(n.target), t || Pt(n)), !e.dragoverBubble && n.stopPropagation && n.stopPropagation(), p = !0 } function A() { tt = F(z), nt = F(z, e.draggable), W({ sortable: f, name: 'change', toEl: l, newIndex: tt, newDraggableIndex: nt, originalEvent: n }) } }, _ignoreWhileAnimating: null, _offMoveEvents: function () { s(document, 'mousemove', this._onTouchMove), s(document, 'touchmove', this._onTouchMove), s(document, 'pointermove', this._onTouchMove), s(document, 'dragover', Pt), s(document, 'mousemove', Pt), s(document, 'touchmove', Pt) }, _offUpEvents: function () { const t = this.el.ownerDocument; s(t, 'mouseup', this._onDrop), s(t, 'touchend', this._onDrop), s(t, 'pointerup', this._onDrop), s(t, 'touchcancel', this._onDrop), s(document, 'selectstart', this) }, _onDrop: function (t) { const e = this.el; const n = this.options; tt = F(z), nt = F(z, n.draggable), K('drop', this, { evt: t }), G = z && z.parentNode, tt = F(z), nt = F(z, n.draggable), Rt.eventCanceled || (yt = wt = vt = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Lt(this.cloneId), Lt(this._dragStartId), this.nativeDraggable && (s(document, 'drop', this), s(e, 'dragstart', this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), u && R(document.body, 'user-select', ''), R(z, 'transform', ''), t && (dt && (t.cancelable && t.preventDefault(), n.dropBubble || t.stopPropagation()), U && U.parentNode && U.parentNode.removeChild(U), (q === G || it && it.lastPutMode !== 'clone') && Q && Q.parentNode && Q.parentNode.removeChild(Q), z && (this.nativeDraggable && s(z, 'dragend', this), Yt(z), z.style['will-change'] = '', dt && !vt && k(z, it ? it.options.ghostClass : this.options.ghostClass, !1), k(z, this.options.chosenClass, !1), W({ sortable: this, name: 'unchoose', toEl: G, newIndex: null, newDraggableIndex: null, originalEvent: t }), q !== G ? (tt >= 0 && (W({ rootEl: G, name: 'add', toEl: G, fromEl: q, originalEvent: t }), W({ sortable: this, name: 'remove', toEl: G, originalEvent: t }), W({ rootEl: G, name: 'sort', toEl: G, fromEl: q, originalEvent: t }), W({ sortable: this, name: 'sort', toEl: G, originalEvent: t })), it && it.save()) : tt !== J && tt >= 0 && (W({ sortable: this, name: 'update', toEl: G, originalEvent: t }), W({ sortable: this, name: 'sort', toEl: G, originalEvent: t })), Rt.active && (tt != null && tt !== -1 || (tt = J, nt = et), W({ sortable: this, name: 'end', toEl: G, originalEvent: t }), this.save())))), this._nulling() }, _nulling: function () { K('nulling', this), q = z = G = U = V = Q = Z = $ = rt = at = dt = tt = nt = J = et = ht = ft = it = ot = Rt.dragged = Rt.ghost = Rt.clone = Rt.active = null, St.forEach(function (t) { t.checked = !0 }), St.length = lt = st = 0 }, handleEvent: function (t) { switch (t.type) { case 'drop':case 'dragend':this._onDrop(t); break; case 'dragenter':case 'dragover':z && (this._onDragOver(t), (function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = 'move'); t.cancelable && t.preventDefault() }(t))); break; case 'selectstart':t.preventDefault() } }, toArray: function () { for (var t, e = [], n = this.el.children, o = 0, i = n.length, r = this.options; o < i; o++)P(t = n[o], r.draggable, this.el, !1) && e.push(t.getAttribute(r.dataIdAttr) || Ft(t)); return e }, sort: function (t, e) { const o = {}; const i = this.el; this.toArray().forEach(function (t, e) { const n = i.children[e]; P(n, this.options.draggable, i, !1) && (o[t] = n) }, this), e && this.captureAnimationState(), t.forEach(function (t) { o[t] && (i.removeChild(o[t]), i.appendChild(o[t])) }), e && this.animateAll() }, save: function () { const t = this.options.store; t && t.set && t.set(this) }, closest: function (t, e) { return P(t, e || this.options.draggable, this.el, !1) }, option: function (t, e) { const n = this.options; if (void 0 === e) return n[t]; const o = O.modifyOption(this, t, e); n[t] = void 0 !== o ? o : e, t === 'group' && Nt(n) }, destroy: function () { K('destroy', this); let t = this.el; t[j] = null, s(t, 'mousedown', this._onTapStart), s(t, 'touchstart', this._onTapStart), s(t, 'pointerdown', this._onTapStart), this.nativeDraggable && (s(t, 'dragover', this), s(t, 'dragenter', this)), Array.prototype.forEach.call(t.querySelectorAll('[draggable]'), function (t) { t.removeAttribute('draggable') }), this._onDrop(), this._disableDelayedDragEvents(), bt.splice(bt.indexOf(this.el), 1), this.el = t = null }, _hideClone: function () { if (!$) { if (K('hideClone', this), Rt.eventCanceled) return; R(Q, 'display', 'none'), this.options.removeCloneOnHide && Q.parentNode && Q.parentNode.removeChild(Q), $ = !0 } }, _showClone: function (t) { if (t.lastPutMode === 'clone') { if ($) { if (K('showClone', this), Rt.eventCanceled) return; z.parentNode != q || this.options.group.revertClone ? V ? q.insertBefore(Q, V) : q.appendChild(Q) : q.insertBefore(Q, z), this.options.group.revertClone && this.animate(z, Q), R(Q, 'display', ''), $ = !1 } } else this._hideClone() } }, _t && d(document, 'touchmove', function (t) { (Rt.active || vt) && t.cancelable && t.preventDefault() }), Rt.utils = { on: d, off: s, css: R, find: g, is: function (t, e) { return !!P(t, e, t, !1) }, extend: function (t, e) { if (t && e) for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); return t }, throttle: D, closest: P, toggleClass: k, clone: S, index: F, nextTick: Ht, cancelNextTick: Lt, detectDirection: Ot, getChild: m }, Rt.get = function (t) { return t[j] }, Rt.mount = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; e[0].constructor === Array && (e = e[0]), e.forEach(function (t) { if (!t.prototype || !t.prototype.constructor) throw 'Sortable: Mounted plugin must be a constructor function, not '.concat({}.toString.call(t)); t.utils && (Rt.utils = I({}, Rt.utils, t.utils)), O.mount(t) }) }, Rt.create = function (t, e) { return new Rt(t, e) }; let jt; let Kt; let Wt; let zt; let Gt; let Ut; let qt = []; let Vt = !(Rt.version = '1.13.0'); function Zt() { qt.forEach(function (t) { clearInterval(t.pid) }), qt = [] } function Qt() { clearInterval(Ut) } function $t(t) { const e = t.originalEvent; const n = t.putSortable; const o = t.dragEl; const i = t.activeSortable; const r = t.dispatchSortableEvent; const a = t.hideGhostForTarget; const l = t.unhideGhostForTarget; if (e) { const s = n || i; a(); const c = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e; const u = document.elementFromPoint(c.clientX, c.clientY); l(), s && !s.el.contains(u) && (r('spill'), this.onSpill({ dragEl: o, putSortable: n })) } } let Jt; const te = D(function (n, t, e, o) { if (t.scroll) { let i; const r = (n.touches ? n.touches[0] : n).clientX; const a = (n.touches ? n.touches[0] : n).clientY; const l = t.scrollSensitivity; const s = t.scrollSpeed; const c = A(); let u = !1; Kt !== e && (Kt = e, Zt(), jt = t.scroll, i = t.scrollFn, !0 === jt && (jt = H(e, !0))); let d = 0; let h = jt; do { const f = h; const p = X(f); const g = p.top; const v = p.bottom; const m = p.left; const b = p.right; const y = p.width; const w = p.height; let E = void 0; let D = void 0; const S = f.scrollWidth; const _ = f.scrollHeight; const C = R(f); const T = f.scrollLeft; const x = f.scrollTop; D = f === c ? (E = y < S && (C.overflowX === 'auto' || C.overflowX === 'scroll' || C.overflowX === 'visible'), w < _ && (C.overflowY === 'auto' || C.overflowY === 'scroll' || C.overflowY === 'visible')) : (E = y < S && (C.overflowX === 'auto' || C.overflowX === 'scroll'), w < _ && (C.overflowY === 'auto' || C.overflowY === 'scroll')); const M = E && (Math.abs(b - r) <= l && T + y < S) - (Math.abs(m - r) <= l && !!T); const O = D && (Math.abs(v - a) <= l && x + w < _) - (Math.abs(g - a) <= l && !!x); if (!qt[d]) for (let N = 0; N <= d; N++)qt[N] || (qt[N] = {}); qt[d].vx == M && qt[d].vy == O && qt[d].el === f || (qt[d].el = f, qt[d].vx = M, qt[d].vy = O, clearInterval(qt[d].pid), M == 0 && O == 0 || (u = !0, qt[d].pid = setInterval(function () { o && this.layer === 0 && Rt.active._onTouchMove(Gt); const t = qt[this.layer].vy ? qt[this.layer].vy * s : 0; const e = qt[this.layer].vx ? qt[this.layer].vx * s : 0; typeof i === 'function' && i.call(Rt.dragged.parentNode[j], e, t, n, Gt, qt[this.layer].el) !== 'continue' || L(qt[this.layer].el, e, t) }.bind({ layer: d }), 24))), d++ } while (t.bubbleScroll && h !== c && (h = H(h, !1))); Vt = u } }, 30); function ee() {} function ne() {}ee.prototype = { startIndex: null, dragStart: function (t) { const e = t.oldDraggableIndex; this.startIndex = e }, onSpill: function (t) { const e = t.dragEl; const n = t.putSortable; this.sortable.captureAnimationState(), n && n.captureAnimationState(); const o = m(this.sortable.el, this.startIndex, this.options); o ? this.sortable.el.insertBefore(e, o) : this.sortable.el.appendChild(e), this.sortable.animateAll(), n && n.animateAll() }, drop: $t }, a(ee, { pluginName: 'revertOnSpill' }), ne.prototype = { onSpill: function (t) { const e = t.dragEl; const n = t.putSortable || this.sortable; n.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), n.animateAll() }, drop: $t }, a(ne, { pluginName: 'removeOnSpill' }); let oe; let ie; let re; let ae; let le; let se = []; const ce = []; let ue = !1; let de = !1; let he = !1; function fe(o, i) { ce.forEach(function (t, e) { const n = i.children[t.sortableIndex + (o ? Number(e) : 0)]; n ? i.insertBefore(t, n) : i.appendChild(t) }) } function pe() { se.forEach(function (t) { t !== re && t.parentNode && t.parentNode.removeChild(t) }) } return Rt.mount(new function () { function t() { for (const t in this.defaults = { scroll: !0, scrollSensitivity: 30, scrollSpeed: 10, bubbleScroll: !0 }, this)t.charAt(0) === '_' && typeof this[t] === 'function' && (this[t] = this[t].bind(this)) } return t.prototype = { dragStarted: function (t) { const e = t.originalEvent; this.sortable.nativeDraggable ? d(document, 'dragover', this._handleAutoScroll) : this.options.supportPointer ? d(document, 'pointermove', this._handleFallbackAutoScroll) : e.touches ? d(document, 'touchmove', this._handleFallbackAutoScroll) : d(document, 'mousemove', this._handleFallbackAutoScroll) }, dragOverCompleted: function (t) { const e = t.originalEvent; this.options.dragOverBubble || e.rootEl || this._handleAutoScroll(e) }, drop: function () { this.sortable.nativeDraggable ? s(document, 'dragover', this._handleAutoScroll) : (s(document, 'pointermove', this._handleFallbackAutoScroll), s(document, 'touchmove', this._handleFallbackAutoScroll), s(document, 'mousemove', this._handleFallbackAutoScroll)), Qt(), Zt(), clearTimeout(f), f = void 0 }, nulling: function () { Gt = Kt = jt = Vt = Ut = Wt = zt = null, qt.length = 0 }, _handleFallbackAutoScroll: function (t) { this._handleAutoScroll(t, !0) }, _handleAutoScroll: function (e, n) { const o = this; const i = (e.touches ? e.touches[0] : e).clientX; const r = (e.touches ? e.touches[0] : e).clientY; const t = document.elementFromPoint(i, r); if (Gt = e, n || E || w || u) { te(e, this.options, t, n); let a = H(t, !0); !Vt || Ut && i === Wt && r === zt || (Ut && Qt(), Ut = setInterval(function () { const t = H(document.elementFromPoint(i, r), !0); t !== a && (a = t, Zt()), te(e, o.options, t, n) }, 10), Wt = i, zt = r) } else { if (!this.options.bubbleScroll || H(t, !0) === A()) return void Zt(); te(e, this.options, H(t, !1), !1) } } }, a(t, { pluginName: 'scroll', initializeByDefault: !0 }) }()), Rt.mount(ne, ee), Rt.mount(new function () { function t() { this.defaults = { swapClass: 'sortable-swap-highlight' } } return t.prototype = { dragStart: function (t) { const e = t.dragEl; Jt = e }, dragOverValid: function (t) { const e = t.completed; const n = t.target; const o = t.onMove; const i = t.activeSortable; const r = t.changed; const a = t.cancel; if (i.options.swap) { const l = this.sortable.el; const s = this.options; if (n && n !== l) { const c = Jt; Jt = !1 !== o(n) ? (k(n, s.swapClass, !0), n) : null, c && c !== Jt && k(c, s.swapClass, !1) }r(), e(!0), a() } }, drop: function (t) { const e = t.activeSortable; const n = t.putSortable; const o = t.dragEl; const i = n || this.sortable; const r = this.options; Jt && k(Jt, r.swapClass, !1), Jt && (r.swap || n && n.options.swap) && o !== Jt && (i.captureAnimationState(), i !== e && e.captureAnimationState(), (function (t, e) { let n; let o; const i = t.parentNode; const r = e.parentNode; if (!i || !r || i.isEqualNode(e) || r.isEqualNode(t)) return; n = F(t), o = F(e), i.isEqualNode(r) && n < o && o++; i.insertBefore(e, i.children[n]), r.insertBefore(t, r.children[o]) }(o, Jt)), i.animateAll(), i !== e && e.animateAll()) }, nulling: function () { Jt = null } }, a(t, { pluginName: 'swap', eventProperties: function () { return { swapItem: Jt } } }) }()), Rt.mount(new function () { function t(o) { for (const t in this)t.charAt(0) === '_' && typeof this[t] === 'function' && (this[t] = this[t].bind(this)); o.options.supportPointer ? d(document, 'pointerup', this._deselectMultiDrag) : (d(document, 'mouseup', this._deselectMultiDrag), d(document, 'touchend', this._deselectMultiDrag)), d(document, 'keydown', this._checkKeyDown), d(document, 'keyup', this._checkKeyUp), this.defaults = { selectedClass: 'sortable-selected', multiDragKey: null, setData: function (t, e) { let n = ''; se.length && ie === o ? se.forEach(function (t, e) { n += (e ? ', ' : '') + t.textContent }) : n = e.textContent, t.setData('Text', n) } } } return t.prototype = { multiDragKeyDown: !1, isMultiDrag: !1, delayStartGlobal: function (t) { const e = t.dragEl; re = e }, delayEnded: function () { this.isMultiDrag = ~se.indexOf(re) }, setupClone: function (t) { const e = t.sortable; const n = t.cancel; if (this.isMultiDrag) { for (let o = 0; o < se.length; o++)ce.push(S(se[o])), ce[o].sortableIndex = se[o].sortableIndex, ce[o].draggable = !1, ce[o].style['will-change'] = '', k(ce[o], this.options.selectedClass, !1), se[o] === re && k(ce[o], this.options.chosenClass, !1); e._hideClone(), n() } }, clone: function (t) { const e = t.sortable; const n = t.rootEl; const o = t.dispatchSortableEvent; const i = t.cancel; this.isMultiDrag && (this.options.removeCloneOnHide || se.length && ie === e && (fe(!0, n), o('clone'), i())) }, showClone: function (t) { const e = t.cloneNowShown; const n = t.rootEl; const o = t.cancel; this.isMultiDrag && (fe(!1, n), ce.forEach(function (t) { R(t, 'display', '') }), e(), le = !1, o()) }, hideClone: function (t) { const e = this; const n = (t.sortable, t.cloneNowHidden); const o = t.cancel; this.isMultiDrag && (ce.forEach(function (t) { R(t, 'display', 'none'), e.options.removeCloneOnHide && t.parentNode && t.parentNode.removeChild(t) }), n(), le = !0, o()) }, dragStartGlobal: function (t) { t.sortable; !this.isMultiDrag && ie && ie.multiDrag._deselectMultiDrag(), se.forEach(function (t) { t.sortableIndex = F(t) }), se = se.sort(function (t, e) { return t.sortableIndex - e.sortableIndex }), he = !0 }, dragStarted: function (t) { const e = this; const n = t.sortable; if (this.isMultiDrag) { if (this.options.sort && (n.captureAnimationState(), this.options.animation)) { se.forEach(function (t) { t !== re && R(t, 'position', 'absolute') }); const o = X(re, !1, !0, !0); se.forEach(function (t) { t !== re && _(t, o) }), ue = de = !0 }n.animateAll(function () { ue = de = !1, e.options.animation && se.forEach(function (t) { C(t) }), e.options.sort && pe() }) } }, dragOver: function (t) { const e = t.target; const n = t.completed; const o = t.cancel; de && ~se.indexOf(e) && (n(!1), o()) }, revert: function (t) { const e = t.fromSortable; const n = t.rootEl; const o = t.sortable; const i = t.dragRect; se.length > 1 && (se.forEach(function (t) { o.addAnimationState({ target: t, rect: de ? X(t) : i }), C(t), t.fromRect = i, e.removeAnimationState(t) }), de = !1, (function (o, i) { se.forEach(function (t, e) { const n = i.children[t.sortableIndex + (o ? Number(e) : 0)]; n ? i.insertBefore(t, n) : i.appendChild(t) }) }(!this.options.removeCloneOnHide, n))) }, dragOverCompleted: function (t) { const e = t.sortable; const n = t.isOwner; const o = t.insertion; const i = t.activeSortable; const r = t.parentEl; const a = t.putSortable; const l = this.options; if (o) { if (n && i._hideClone(), ue = !1, l.animation && se.length > 1 && (de || !n && !i.options.sort && !a)) { const s = X(re, !1, !0, !0); se.forEach(function (t) { t !== re && (_(t, s), r.appendChild(t)) }), de = !0 } if (!n) if (de || pe(), se.length > 1) { const c = le; i._showClone(e), i.options.animation && !le && c && ce.forEach(function (t) { i.addAnimationState({ target: t, rect: ae }), t.fromRect = ae, t.thisAnimationDuration = null }) } else i._showClone(e) } }, dragOverAnimationCapture: function (t) { const e = t.dragRect; const n = t.isOwner; const o = t.activeSortable; if (se.forEach(function (t) { t.thisAnimationDuration = null }), o.options.animation && !n && o.multiDrag.isMultiDrag) { ae = a({}, e); const i = v(re, !0); ae.top -= i.f, ae.left -= i.e } }, dragOverAnimationComplete: function () { de && (de = !1, pe()) }, drop: function (t) { const e = t.originalEvent; const n = t.rootEl; const o = t.parentEl; const i = t.sortable; const r = t.dispatchSortableEvent; const a = t.oldIndex; const l = t.putSortable; const s = l || this.sortable; if (e) { const c = this.options; const u = o.children; if (!he) if (c.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), k(re, c.selectedClass, !~se.indexOf(re)), ~se.indexOf(re))se.splice(se.indexOf(re), 1), oe = null, N({ sortable: i, rootEl: n, name: 'deselect', targetEl: re, originalEvt: e }); else { if (se.push(re), N({ sortable: i, rootEl: n, name: 'select', targetEl: re, originalEvt: e }), e.shiftKey && oe && i.el.contains(oe)) { let d; let h; const f = F(oe); const p = F(re); if (~f && ~p && f !== p) for (d = f < p ? (h = f, p) : (h = p, f + 1); h < d; h++)~se.indexOf(u[h]) || (k(u[h], c.selectedClass, !0), se.push(u[h]), N({ sortable: i, rootEl: n, name: 'select', targetEl: u[h], originalEvt: e })) } else oe = re; ie = s } if (he && this.isMultiDrag) { if ((o[j].options.sort || o !== n) && se.length > 1) { const g = X(re); let v = F(re, ':not(.' + this.options.selectedClass + ')'); if (!ue && c.animation && (re.thisAnimationDuration = null), s.captureAnimationState(), !ue && (c.animation && (re.fromRect = g, se.forEach(function (t) { if (t.thisAnimationDuration = null, t !== re) { const e = de ? X(t) : g; t.fromRect = e, s.addAnimationState({ target: t, rect: e }) } })), pe(), se.forEach(function (t) { u[v] ? o.insertBefore(t, u[v]) : o.appendChild(t), v++ }), a === F(re))) { let m = !1; se.forEach(function (t) { t.sortableIndex === F(t) || (m = !0) }), m && r('update') }se.forEach(function (t) { C(t) }), s.animateAll() }ie = s }(n === o || l && l.lastPutMode !== 'clone') && ce.forEach(function (t) { t.parentNode && t.parentNode.removeChild(t) }) } }, nullingGlobal: function () { this.isMultiDrag = he = !1, ce.length = 0 }, destroyGlobal: function () { this._deselectMultiDrag(), s(document, 'pointerup', this._deselectMultiDrag), s(document, 'mouseup', this._deselectMultiDrag), s(document, 'touchend', this._deselectMultiDrag), s(document, 'keydown', this._checkKeyDown), s(document, 'keyup', this._checkKeyUp) }, _deselectMultiDrag: function (t) { if (!(void 0 !== he && he || ie !== this.sortable || t && P(t.target, this.options.draggable, this.sortable.el, !1) || t && t.button !== 0)) for (;se.length;) { const e = se[0]; k(e, this.options.selectedClass, !1), se.shift(), N({ sortable: this.sortable, rootEl: this.sortable.el, name: 'deselect', targetEl: e, originalEvt: t }) } }, _checkKeyDown: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0) }, _checkKeyUp: function (t) { t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1) } }, a(t, { pluginName: 'multiDrag', utils: { select: function (t) { const e = t.parentNode[j]; e && e.options.multiDrag && !~se.indexOf(t) && (ie && ie !== e && (ie.multiDrag._deselectMultiDrag(), ie = e), k(t, e.options.selectedClass, !0), se.push(t)) }, deselect: function (t) { const e = t.parentNode[j]; const n = se.indexOf(t); e && e.options.multiDrag && ~n && (k(t, e.options.selectedClass, !1), se.splice(n, 1)) } }, eventProperties: function () { const n = this; const o = []; const i = []; return se.forEach(function (t) { let e; o.push({ multiDragElement: t, index: t.sortableIndex }), e = de && t !== re ? -1 : de ? F(t, ':not(.' + n.options.selectedClass + ')') : F(t), i.push({ multiDragElement: t, index: e }) }), { items: e(se), clones: [].concat(ce), oldIndicies: o, newIndicies: i } }, optionListeners: { multiDragKey: function (t) { return (t = t.toLowerCase()) === 'ctrl' ? t = 'Control' : t.length > 1 && (t = t.charAt(0).toUpperCase() + t.substr(1)), t } } }) }()), Rt }))