/* !
FullCalendar Interaction Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports, require('@fullcalendar/core')) : typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], t) : t((e = e || self).FullCalendarInteraction = {}, e.FullCalendar) }(this, function (e, t) { 'use strict'; var n = function (e, t) { return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (const n in t)t.hasOwnProperty(n) && (e[n] = t[n]) })(e, t) }; function r(e, t) { function r() { this.constructor = e }n(e, t), e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r()) } var i = function () { return (i = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) for (const i in t = arguments[n])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }).apply(this, arguments) }; t.config.touchMouseIgnoreWait = 500; let o = 0; let a = 0; let l = !1; const s = (function () { function e(e) { const n = this; this.subjectEl = null, this.downEl = null, this.selector = '', this.handleSelector = '', this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = function (e) { if (!n.shouldIgnoreMouse() && (function (e) { return e.button === 0 && !e.ctrlKey }(e)) && n.tryStart(e)) { const t = n.createEventFromMouse(e, !0); n.emitter.trigger('pointerdown', t), n.initScrollWatch(t), n.shouldIgnoreMove || document.addEventListener('mousemove', n.handleMouseMove), document.addEventListener('mouseup', n.handleMouseUp) } }, this.handleMouseMove = function (e) { const t = n.createEventFromMouse(e); n.recordCoords(t), n.emitter.trigger('pointermove', t) }, this.handleMouseUp = function (e) { document.removeEventListener('mousemove', n.handleMouseMove), document.removeEventListener('mouseup', n.handleMouseUp), n.emitter.trigger('pointerup', n.createEventFromMouse(e)), n.cleanup() }, this.handleTouchStart = function (e) { if (n.tryStart(e)) { n.isTouchDragging = !0; const t = n.createEventFromTouch(e, !0); n.emitter.trigger('pointerdown', t), n.initScrollWatch(t); const r = e.target; n.shouldIgnoreMove || r.addEventListener('touchmove', n.handleTouchMove), r.addEventListener('touchend', n.handleTouchEnd), r.addEventListener('touchcancel', n.handleTouchEnd), window.addEventListener('scroll', n.handleTouchScroll, !0) } }, this.handleTouchMove = function (e) { const t = n.createEventFromTouch(e); n.recordCoords(t), n.emitter.trigger('pointermove', t) }, this.handleTouchEnd = function (e) { if (n.isDragging) { const r = e.target; r.removeEventListener('touchmove', n.handleTouchMove), r.removeEventListener('touchend', n.handleTouchEnd), r.removeEventListener('touchcancel', n.handleTouchEnd), window.removeEventListener('scroll', n.handleTouchScroll, !0), n.emitter.trigger('pointerup', n.createEventFromTouch(e)), n.cleanup(), n.isTouchDragging = !1, o++, setTimeout(function () { o-- }, t.config.touchMouseIgnoreWait) } }, this.handleTouchScroll = function () { n.wasTouchScroll = !0 }, this.handleScroll = function (e) { if (!n.shouldIgnoreMove) { const t = window.pageXOffset - n.prevScrollX + n.prevPageX; const r = window.pageYOffset - n.prevScrollY + n.prevPageY; n.emitter.trigger('pointermove', { origEvent: e, isTouch: n.isTouchDragging, subjectEl: n.subjectEl, pageX: t, pageY: r, deltaX: t - n.origPageX, deltaY: r - n.origPageY }) } }, this.containerEl = e, this.emitter = new t.EmitterMixin(), e.addEventListener('mousedown', this.handleMouseDown), e.addEventListener('touchstart', this.handleTouchStart, { passive: !0 }), a++ || window.addEventListener('touchmove', c, { passive: !1 }) } return e.prototype.destroy = function () { this.containerEl.removeEventListener('mousedown', this.handleMouseDown), this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: !0 }), --a || window.removeEventListener('touchmove', c, { passive: !1 }) }, e.prototype.tryStart = function (e) { const n = this.querySubjectEl(e); const r = e.target; return !(!n || this.handleSelector && !t.elementClosest(r, this.handleSelector)) && (this.subjectEl = n, this.downEl = r, this.isDragging = !0, this.wasTouchScroll = !1, !0) }, e.prototype.cleanup = function () { l = !1, this.isDragging = !1, this.subjectEl = null, this.downEl = null, this.destroyScrollWatch() }, e.prototype.querySubjectEl = function (e) { return this.selector ? t.elementClosest(e.target, this.selector) : this.containerEl }, e.prototype.shouldIgnoreMouse = function () { return o || this.isTouchDragging }, e.prototype.cancelTouchScroll = function () { this.isDragging && (l = !0) }, e.prototype.initScrollWatch = function (e) { this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener('scroll', this.handleScroll, !0)) }, e.prototype.recordCoords = function (e) { this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.pageXOffset, this.prevScrollY = window.pageYOffset) }, e.prototype.destroyScrollWatch = function () { this.shouldWatchScroll && window.removeEventListener('scroll', this.handleScroll, !0) }, e.prototype.createEventFromMouse = function (e, t) { let n = 0; let r = 0; return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (n = e.pageX - this.origPageX, r = e.pageY - this.origPageY), { origEvent: e, isTouch: !1, subjectEl: this.subjectEl, pageX: e.pageX, pageY: e.pageY, deltaX: n, deltaY: r } }, e.prototype.createEventFromTouch = function (e, t) { let n; let r; const i = e.touches; let o = 0; let a = 0; return i && i.length ? (n = i[0].pageX, r = i[0].pageY) : (n = e.pageX, r = e.pageY), t ? (this.origPageX = n, this.origPageY = r) : (o = n - this.origPageX, a = r - this.origPageY), { origEvent: e, isTouch: !0, subjectEl: this.subjectEl, pageX: n, pageY: r, deltaX: o, deltaY: a } }, e }()); function c(e) { l && e.preventDefault() } const d = (function () { function e() { this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0 } return e.prototype.start = function (e, t, n) { this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.pageXOffset, this.origScreenY = n - window.pageYOffset, this.deltaX = 0, this.deltaY = 0, this.updateElPosition() }, e.prototype.handleMove = function (e, t) { this.deltaX = e - window.pageXOffset - this.origScreenX, this.deltaY = t - window.pageYOffset - this.origScreenY, this.updateElPosition() }, e.prototype.setIsVisible = function (e) { e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ''), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = 'none'), this.isVisible = e) }, e.prototype.stop = function (e, t) { const n = this; const r = function () { n.cleanup(), t() }; e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(r, this.revertDuration) : setTimeout(r, 0) }, e.prototype.doRevertAnimation = function (e, n) { const r = this.mirrorEl; const i = this.sourceEl.getBoundingClientRect(); r.style.transition = 'top ' + n + 'ms,left ' + n + 'ms', t.applyStyle(r, { left: i.left, top: i.top }), t.whenTransitionDone(r, function () { r.style.transition = '', e() }) }, e.prototype.cleanup = function () { this.mirrorEl && (t.removeElement(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null }, e.prototype.updateElPosition = function () { this.sourceEl && this.isVisible && t.applyStyle(this.getMirrorEl(), { left: this.sourceElRect.left + this.deltaX, top: this.sourceElRect.top + this.deltaY }) }, e.prototype.getMirrorEl = function () { const e = this.sourceElRect; let n = this.mirrorEl; return n || ((n = this.mirrorEl = this.sourceEl.cloneNode(!0)).classList.add('fc-unselectable'), n.classList.add('fc-dragging'), t.applyStyle(n, { position: 'fixed', zIndex: this.zIndex, visibility: '', boxSizing: 'border-box', width: e.right - e.left, height: e.bottom - e.top, right: 'auto', bottom: 'auto', margin: 0 }), this.parentNode.appendChild(n)), n }, e }()); const g = (function (e) { function t(t, n) { const r = e.call(this) || this; return r.handleScroll = function () { r.scrollTop = r.scrollController.getScrollTop(), r.scrollLeft = r.scrollController.getScrollLeft(), r.handleScrollChange() }, r.scrollController = t, r.doesListening = n, r.scrollTop = r.origScrollTop = t.getScrollTop(), r.scrollLeft = r.origScrollLeft = t.getScrollLeft(), r.scrollWidth = t.getScrollWidth(), r.scrollHeight = t.getScrollHeight(), r.clientWidth = t.getClientWidth(), r.clientHeight = t.getClientHeight(), r.clientRect = r.computeClientRect(), r.doesListening && r.getEventTarget().addEventListener('scroll', r.handleScroll), r } return r(t, e), t.prototype.destroy = function () { this.doesListening && this.getEventTarget().removeEventListener('scroll', this.handleScroll) }, t.prototype.getScrollTop = function () { return this.scrollTop }, t.prototype.getScrollLeft = function () { return this.scrollLeft }, t.prototype.setScrollTop = function (e) { this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange()) }, t.prototype.setScrollLeft = function (e) { this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange()) }, t.prototype.getClientWidth = function () { return this.clientWidth }, t.prototype.getClientHeight = function () { return this.clientHeight }, t.prototype.getScrollWidth = function () { return this.scrollWidth }, t.prototype.getScrollHeight = function () { return this.scrollHeight }, t.prototype.handleScrollChange = function () {}, t }(t.ScrollController)); const u = (function (e) { function n(n, r) { return e.call(this, new t.ElementScrollController(n), r) || this } return r(n, e), n.prototype.getEventTarget = function () { return this.scrollController.el }, n.prototype.computeClientRect = function () { return t.computeInnerRect(this.scrollController.el) }, n }(g)); const h = (function (e) { function n(n) { return e.call(this, new t.WindowScrollController(), n) || this } return r(n, e), n.prototype.getEventTarget = function () { return window }, n.prototype.computeClientRect = function () { return { left: this.scrollLeft, right: this.scrollLeft + this.clientWidth, top: this.scrollTop, bottom: this.scrollTop + this.clientHeight } }, n.prototype.handleScrollChange = function () { this.clientRect = this.computeClientRect() }, n }(g)); const p = typeof performance === 'function' ? performance.now : Date.now; const v = (function () { function e() { const e = this; this.isEnabled = !0, this.scrollQuery = [window, '.fc-scroller'], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = function () { if (e.isAnimating) { const t = e.computeBestEdge(e.pointerScreenX + window.pageXOffset, e.pointerScreenY + window.pageYOffset); if (t) { const n = p(); e.handleSide(t, (n - e.msSinceRequest) / 1e3), e.requestAnimation(n) } else e.isAnimating = !1 } } } return e.prototype.start = function (e, t) { this.isEnabled && (this.scrollCaches = this.buildCaches(), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t)) }, e.prototype.handleMove = function (e, t) { if (this.isEnabled) { const n = e - window.pageXOffset; const r = t - window.pageYOffset; const i = this.pointerScreenY === null ? 0 : r - this.pointerScreenY; const o = this.pointerScreenX === null ? 0 : n - this.pointerScreenX; i < 0 ? this.everMovedUp = !0 : i > 0 && (this.everMovedDown = !0), o < 0 ? this.everMovedLeft = !0 : o > 0 && (this.everMovedRight = !0), this.pointerScreenX = n, this.pointerScreenY = r, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(p())) } }, e.prototype.stop = function () { if (this.isEnabled) { this.isAnimating = !1; for (let e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy() } this.scrollCaches = null } }, e.prototype.requestAnimation = function (e) { this.msSinceRequest = e, requestAnimationFrame(this.animate) }, e.prototype.handleSide = function (e, t) { const n = e.scrollCache; const r = this.edgeThreshold; const i = r - e.distance; const o = i * i / (r * r) * this.maxVelocity * t; let a = 1; switch (e.name) { case 'left':a = -1; case 'right':n.setScrollLeft(n.getScrollLeft() + o * a); break; case 'top':a = -1; case 'bottom':n.setScrollTop(n.getScrollTop() + o * a) } }, e.prototype.computeBestEdge = function (e, t) { for (var n = this.edgeThreshold, r = null, i = 0, o = this.scrollCaches; i < o.length; i++) { const a = o[i]; const l = a.clientRect; const s = e - l.left; const c = l.right - e; const d = t - l.top; const g = l.bottom - t; s >= 0 && c >= 0 && d >= 0 && g >= 0 && (d <= n && this.everMovedUp && a.canScrollUp() && (!r || r.distance > d) && (r = { scrollCache: a, name: 'top', distance: d }), g <= n && this.everMovedDown && a.canScrollDown() && (!r || r.distance > g) && (r = { scrollCache: a, name: 'bottom', distance: g }), s <= n && this.everMovedLeft && a.canScrollLeft() && (!r || r.distance > s) && (r = { scrollCache: a, name: 'left', distance: s }), c <= n && this.everMovedRight && a.canScrollRight() && (!r || r.distance > c) && (r = { scrollCache: a, name: 'right', distance: c })) } return r }, e.prototype.buildCaches = function () { return this.queryScrollEls().map(function (e) { return e === window ? new h(!1) : new u(e, !1) }) }, e.prototype.queryScrollEls = function () { for (var e = [], t = 0, n = this.scrollQuery; t < n.length; t++) { const r = n[t]; typeof r === 'object' ? e.push(r) : e.push.apply(e, Array.prototype.slice.call(document.querySelectorAll(r))) } return e }, e }()); const f = (function (e) { function n(n) { const r = e.call(this, n) || this; r.delay = null, r.minDistance = 0, r.touchScrollAllowed = !0, r.mirrorNeedsRevert = !1, r.isInteracting = !1, r.isDragging = !1, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, r.delayTimeoutId = null, r.onPointerDown = function (e) { r.isDragging || (r.isInteracting = !0, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, t.preventSelection(document.body), t.preventContextMenu(document.body), e.isTouch || e.origEvent.preventDefault(), r.emitter.trigger('pointerdown', e), r.pointer.shouldIgnoreMove || (r.mirror.setIsVisible(!1), r.mirror.start(e.subjectEl, e.pageX, e.pageY), r.startDelay(e), r.minDistance || r.handleDistanceSurpassed(e))) }, r.onPointerMove = function (e) { if (r.isInteracting) { if (r.emitter.trigger('pointermove', e), !r.isDistanceSurpassed) { const t = r.minDistance; const n = e.deltaX; const i = e.deltaY; n * n + i * i >= t * t && r.handleDistanceSurpassed(e) }r.isDragging && (e.origEvent.type !== 'scroll' && (r.mirror.handleMove(e.pageX, e.pageY), r.autoScroller.handleMove(e.pageX, e.pageY)), r.emitter.trigger('dragmove', e)) } }, r.onPointerUp = function (e) { r.isInteracting && (r.isInteracting = !1, t.allowSelection(document.body), t.allowContextMenu(document.body), r.emitter.trigger('pointerup', e), r.isDragging && (r.autoScroller.stop(), r.tryStopDrag(e)), r.delayTimeoutId && (clearTimeout(r.delayTimeoutId), r.delayTimeoutId = null)) }; const i = r.pointer = new s(n); return i.emitter.on('pointerdown', r.onPointerDown), i.emitter.on('pointermove', r.onPointerMove), i.emitter.on('pointerup', r.onPointerUp), r.mirror = new d(), r.autoScroller = new v(), r } return r(n, e), n.prototype.destroy = function () { this.pointer.destroy() }, n.prototype.startDelay = function (e) { const t = this; typeof this.delay === 'number' ? this.delayTimeoutId = setTimeout(function () { t.delayTimeoutId = null, t.handleDelayEnd(e) }, this.delay) : this.handleDelayEnd(e) }, n.prototype.handleDelayEnd = function (e) { this.isDelayEnded = !0, this.tryStartDrag(e) }, n.prototype.handleDistanceSurpassed = function (e) { this.isDistanceSurpassed = !0, this.tryStartDrag(e) }, n.prototype.tryStartDrag = function (e) { this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY), this.emitter.trigger('dragstart', e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll())) }, n.prototype.tryStopDrag = function (e) { this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e)) }, n.prototype.stopDrag = function (e) { this.isDragging = !1, this.emitter.trigger('dragend', e) }, n.prototype.setIgnoreMove = function (e) { this.pointer.shouldIgnoreMove = e }, n.prototype.setMirrorIsVisible = function (e) { this.mirror.setIsVisible(e) }, n.prototype.setMirrorNeedsRevert = function (e) { this.mirrorNeedsRevert = e }, n.prototype.setAutoScrollEnabled = function (e) { this.autoScroller.isEnabled = e }, n }(t.ElementDragging)); const E = (function () { function e(e) { this.origRect = t.computeRect(e), this.scrollCaches = t.getClippingParents(e).map(function (e) { return new u(e, !0) }) } return e.prototype.destroy = function () { for (let e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy() } }, e.prototype.computeLeft = function () { for (var e = this.origRect.left, t = 0, n = this.scrollCaches; t < n.length; t++) { const r = n[t]; e += r.origScrollLeft - r.getScrollLeft() } return e }, e.prototype.computeTop = function () { for (var e = this.origRect.top, t = 0, n = this.scrollCaches; t < n.length; t++) { const r = n[t]; e += r.origScrollTop - r.getScrollTop() } return e }, e.prototype.isWithinClipping = function (e, n) { for (var r, i, o = { left: e, top: n }, a = 0, l = this.scrollCaches; a < l.length; a++) { const s = l[a]; if (r = s.getEventTarget(), i = void 0, (i = r.tagName) !== 'HTML' && i !== 'BODY' && !t.pointInsideRect(o, s.clientRect)) return !1 } return !0 }, e }()); const m = (function () { function e(e, n) { const r = this; this.useSubjectCenter = !1, this.requireInitial = !0, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = function (e) { const t = r.dragging; r.initialHit = null, r.movingHit = null, r.finalHit = null, r.prepareHits(), r.processFirstCoord(e), r.initialHit || !r.requireInitial ? (t.setIgnoreMove(!1), r.emitter.trigger('pointerdown', e)) : t.setIgnoreMove(!0) }, this.handleDragStart = function (e) { r.emitter.trigger('dragstart', e), r.handleMove(e, !0) }, this.handleDragMove = function (e) { r.emitter.trigger('dragmove', e), r.handleMove(e) }, this.handlePointerUp = function (e) { r.releaseHits(), r.emitter.trigger('pointerup', e) }, this.handleDragEnd = function (e) { r.movingHit && r.emitter.trigger('hitupdate', null, !0, e), r.finalHit = r.movingHit, r.movingHit = null, r.emitter.trigger('dragend', e) }, this.droppableStore = n, e.emitter.on('pointerdown', this.handlePointerDown), e.emitter.on('dragstart', this.handleDragStart), e.emitter.on('dragmove', this.handleDragMove), e.emitter.on('pointerup', this.handlePointerUp), e.emitter.on('dragend', this.handleDragEnd), this.dragging = e, this.emitter = new t.EmitterMixin() } return e.prototype.processFirstCoord = function (e) { let n; const r = { left: e.pageX, top: e.pageY }; let i = r; const o = e.subjectEl; o !== document && (n = t.computeRect(o), i = t.constrainPoint(i, n)); const a = this.initialHit = this.queryHitForOffset(i.left, i.top); if (a) { if (this.useSubjectCenter && n) { const l = t.intersectRects(n, a.rect); l && (i = t.getRectCenter(l)) } this.coordAdjust = t.diffPoints(i, r) } else this.coordAdjust = { left: 0, top: 0 } }, e.prototype.handleMove = function (e, t) { const n = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top); !t && S(this.movingHit, n) || (this.movingHit = n, this.emitter.trigger('hitupdate', n, !1, e)) }, e.prototype.prepareHits = function () { this.offsetTrackers = t.mapHash(this.droppableStore, function (e) { return e.component.buildPositionCaches(), new E(e.el) }) }, e.prototype.releaseHits = function () { const e = this.offsetTrackers; for (const t in e)e[t].destroy(); this.offsetTrackers = {} }, e.prototype.queryHitForOffset = function (e, n) { const r = this.droppableStore; const i = this.offsetTrackers; let o = null; for (const a in r) { const l = r[a].component; const s = i[a]; if (s.isWithinClipping(e, n)) { const c = s.computeLeft(); const d = s.computeTop(); const g = e - c; const u = n - d; const h = s.origRect; const p = h.right - h.left; const v = h.bottom - h.top; if (g >= 0 && g < p && u >= 0 && u < v) { const f = l.queryHit(g, u, p, v); !f || l.props.dateProfile && !t.rangeContainsRange(l.props.dateProfile.activeRange, f.dateSpan.range) || o && !(f.layer > o.layer) || (f.rect.left += c, f.rect.right += c, f.rect.top += d, f.rect.bottom += d, o = f) } } } return o }, e }()); function S(e, n) { return !e && !n || Boolean(e) === Boolean(n) && t.isDateSpansEqual(e.dateSpan, n.dateSpan) } const y = (function (e) { function n(n) { const r = e.call(this, n) || this; r.handlePointerDown = function (e) { const t = r.dragging; t.setIgnoreMove(!r.component.isValidDateDownEl(t.pointer.downEl)) }, r.handleDragEnd = function (e) { const t = r.component; if (!r.dragging.pointer.wasTouchScroll) { const n = r.hitDragging; const i = n.initialHit; const o = n.finalHit; i && o && S(i, o) && t.calendar.triggerDateClick(i.dateSpan, i.dayEl, t.view, e.origEvent) } }; const i = n.component; r.dragging = new f(i.el), r.dragging.autoScroller.isEnabled = !1; const o = r.hitDragging = new m(r.dragging, t.interactionSettingsToStore(n)); return o.emitter.on('pointerdown', r.handlePointerDown), o.emitter.on('dragend', r.handleDragEnd), r } return r(n, e), n.prototype.destroy = function () { this.dragging.destroy() }, n }(t.Interaction)); const D = (function (e) { function n(n) { const r = e.call(this, n) || this; r.dragSelection = null, r.handlePointerDown = function (e) { const t = r; const n = t.component; const i = t.dragging; const o = n.opt('selectable') && n.isValidDateDownEl(e.origEvent.target); i.setIgnoreMove(!o), i.delay = e.isTouch ? (function (e) { let t = e.opt('selectLongPressDelay'); t == null && (t = e.opt('longPressDelay')); return t }(n)) : null }, r.handleDragStart = function (e) { r.component.calendar.unselect(e) }, r.handleHitUpdate = function (e, n) { const o = r.component.calendar; let a = null; let l = !1; e && ((a = (function (e, n, r) { const o = e.dateSpan; const a = n.dateSpan; const l = [o.range.start, o.range.end, a.range.start, a.range.end]; l.sort(t.compareNumbers); for (var s = {}, c = 0, d = r; c < d.length; c++) { const g = d[c]; const u = g(e, n); if (!1 === u) return null; u && i(s, u) } return s.range = { start: l[0], end: l[3] }, s.allDay = o.allDay, s }(r.hitDragging.initialHit, e, o.pluginSystem.hooks.dateSelectionTransformers))) && r.component.isDateSelectionValid(a) || (l = !0, a = null)), a ? o.dispatch({ type: 'SELECT_DATES', selection: a }) : n || o.dispatch({ type: 'UNSELECT_DATES' }), l ? t.disableCursor() : t.enableCursor(), n || (r.dragSelection = a) }, r.handlePointerUp = function (e) { r.dragSelection && (r.component.calendar.triggerDateSelect(r.dragSelection, e), r.dragSelection = null) }; const o = n.component; const a = r.dragging = new f(o.el); a.touchScrollAllowed = !1, a.minDistance = o.opt('selectMinDistance') || 0, a.autoScroller.isEnabled = o.opt('dragScroll'); const l = r.hitDragging = new m(r.dragging, t.interactionSettingsToStore(n)); return l.emitter.on('pointerdown', r.handlePointerDown), l.emitter.on('dragstart', r.handleDragStart), l.emitter.on('hitupdate', r.handleHitUpdate), l.emitter.on('pointerup', r.handlePointerUp), r } return r(n, e), n.prototype.destroy = function () { this.dragging.destroy() }, n }(t.Interaction)); const w = (function (e) { function n(r) { const o = e.call(this, r) || this; o.subjectSeg = null, o.isDragging = !1, o.eventRange = null, o.relevantEvents = null, o.receivingCalendar = null, o.validMutation = null, o.mutatedRelevantEvents = null, o.handlePointerDown = function (e) { const n = e.origEvent.target; const r = o; const i = r.component; const a = r.dragging; const l = a.mirror; const s = i.calendar; const c = o.subjectSeg = t.getElSeg(e.subjectEl); const d = (o.eventRange = c.eventRange).instance.instanceId; o.relevantEvents = t.getRelevantEvents(s.state.eventStore, d), a.minDistance = e.isTouch ? 0 : i.opt('eventDragMinDistance'), a.delay = e.isTouch && d !== i.props.eventSelection ? (function (e) { let t = e.opt('eventLongPressDelay'); t == null && (t = e.opt('longPressDelay')); return t }(i)) : null, l.parentNode = s.el, l.revertDuration = i.opt('dragRevertDuration'); const g = i.isValidSegDownEl(n) && !t.elementClosest(n, '.fc-resizer'); a.setIgnoreMove(!g), o.isDragging = g && e.subjectEl.classList.contains('fc-draggable') }, o.handleDragStart = function (e) { const n = o.component.calendar; const r = o.eventRange; const i = r.instance.instanceId; e.isTouch ? i !== o.component.props.eventSelection && n.dispatch({ type: 'SELECT_EVENT', eventInstanceId: i }) : n.dispatch({ type: 'UNSELECT_EVENT' }), o.isDragging && (n.unselect(e), n.publiclyTrigger('eventDragStart', [{ el: o.subjectSeg.el, event: new t.EventApi(n, r.def, r.instance), jsEvent: e.origEvent, view: o.component.view }])) }, o.handleHitUpdate = function (e, n) { if (o.isDragging) { const r = o.relevantEvents; const i = o.hitDragging.initialHit; const a = o.component.calendar; let l = null; let s = null; let c = null; let d = !1; const g = { affectedEvents: r, mutatedEvents: t.createEmptyEventStore(), isEvent: !0, origSeg: o.subjectSeg }; if (e) { const u = e.component; a === (l = u.calendar) || u.opt('editable') && u.opt('droppable') ? (s = (function (e, n, r) { const i = e.dateSpan; const o = n.dateSpan; let a = i.range.start; const l = o.range.start; const s = {}; i.allDay !== o.allDay && (s.allDay = o.allDay, s.hasEnd = n.component.opt('allDayMaintainDuration'), o.allDay && (a = t.startOfDay(a))); const c = t.diffDates(a, l, e.component.dateEnv, e.component === n.component ? e.component.largeUnit : null); c.milliseconds && (s.allDay = !1); for (var d = { datesDelta: c, standardProps: s }, g = 0, u = r; g < u.length; g++) { const h = u[g]; h(d, e, n) } return d }(i, e, l.pluginSystem.hooks.eventDragMutationMassagers))) && (c = t.applyMutationToEventStore(r, l.eventUiBases, s, l), g.mutatedEvents = c, u.isInteractionValid(g) || (d = !0, s = null, c = null, g.mutatedEvents = t.createEmptyEventStore())) : l = null }o.displayDrag(l, g), d ? t.disableCursor() : t.enableCursor(), n || (a === l && S(i, e) && (s = null), o.dragging.setMirrorNeedsRevert(!s), o.dragging.setMirrorIsVisible(!e || !document.querySelector('.fc-mirror')), o.receivingCalendar = l, o.validMutation = s, o.mutatedRelevantEvents = c) } }, o.handlePointerUp = function () { o.isDragging || o.cleanup() }, o.handleDragEnd = function (e) { if (o.isDragging) { const n = o.component.calendar; const r = o.component.view; const a = o; const l = a.receivingCalendar; const s = a.validMutation; const c = o.eventRange.def; const d = o.eventRange.instance; const g = new t.EventApi(n, c, d); const u = o.relevantEvents; const h = o.mutatedRelevantEvents; const p = o.hitDragging.finalHit; if (o.clearDrag(), n.publiclyTrigger('eventDragStop', [{ el: o.subjectSeg.el, event: g, jsEvent: e.origEvent, view: r }]), s) { if (l === n) { n.dispatch({ type: 'MERGE_EVENTS', eventStore: h }); for (var v = {}, f = 0, E = n.pluginSystem.hooks.eventDropTransformers; f < E.length; f++) { const m = E[f]; i(v, m(s, n)) } const S = i({}, v, { el: e.subjectEl, delta: s.datesDelta, oldEvent: g, event: new t.EventApi(n, h.defs[c.defId], d ? h.instances[d.instanceId] : null), revert: function () { n.dispatch({ type: 'MERGE_EVENTS', eventStore: u }) }, jsEvent: e.origEvent, view: r }); n.publiclyTrigger('eventDrop', [S]) } else if (l) { n.publiclyTrigger('eventLeave', [{ draggedEl: e.subjectEl, event: g, view: r }]), n.dispatch({ type: 'REMOVE_EVENT_INSTANCES', instances: o.mutatedRelevantEvents.instances }), l.dispatch({ type: 'MERGE_EVENTS', eventStore: o.mutatedRelevantEvents }), e.isTouch && l.dispatch({ type: 'SELECT_EVENT', eventInstanceId: d.instanceId }); const y = i({}, l.buildDatePointApi(p.dateSpan), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: p.component }); l.publiclyTrigger('drop', [y]), l.publiclyTrigger('eventReceive', [{ draggedEl: e.subjectEl, event: new t.EventApi(l, h.defs[c.defId], h.instances[d.instanceId]), view: p.component }]) } } else n.publiclyTrigger('_noEventDrop') }o.cleanup() }; const a = o.component; const l = o.dragging = new f(a.el); l.pointer.selector = n.SELECTOR, l.touchScrollAllowed = !1, l.autoScroller.isEnabled = a.opt('dragScroll'); const s = o.hitDragging = new m(o.dragging, t.interactionSettingsStore); return s.useSubjectCenter = r.useEventCenter, s.emitter.on('pointerdown', o.handlePointerDown), s.emitter.on('dragstart', o.handleDragStart), s.emitter.on('hitupdate', o.handleHitUpdate), s.emitter.on('pointerup', o.handlePointerUp), s.emitter.on('dragend', o.handleDragEnd), o } return r(n, e), n.prototype.destroy = function () { this.dragging.destroy() }, n.prototype.displayDrag = function (e, n) { const r = this.component.calendar; const i = this.receivingCalendar; i && i !== e && (i === r ? i.dispatch({ type: 'SET_EVENT_DRAG', state: { affectedEvents: n.affectedEvents, mutatedEvents: t.createEmptyEventStore(), isEvent: !0, origSeg: n.origSeg } }) : i.dispatch({ type: 'UNSET_EVENT_DRAG' })), e && e.dispatch({ type: 'SET_EVENT_DRAG', state: n }) }, n.prototype.clearDrag = function () { const e = this.component.calendar; const t = this.receivingCalendar; t && t.dispatch({ type: 'UNSET_EVENT_DRAG' }), e !== t && e.dispatch({ type: 'UNSET_EVENT_DRAG' }) }, n.prototype.cleanup = function () { this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingCalendar = null, this.validMutation = null, this.mutatedRelevantEvents = null }, n.SELECTOR = '.fc-draggable, .fc-resizable', n }(t.Interaction)); const T = (function (e) { function n(n) { const r = e.call(this, n) || this; r.draggingSeg = null, r.eventRange = null, r.relevantEvents = null, r.validMutation = null, r.mutatedRelevantEvents = null, r.handlePointerDown = function (e) { const t = r.component; const n = r.querySeg(e); const i = r.eventRange = n.eventRange; r.dragging.minDistance = t.opt('eventDragMinDistance'), r.dragging.setIgnoreMove(!r.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && r.component.props.eventSelection !== i.instance.instanceId) }, r.handleDragStart = function (e) { const n = r.component.calendar; const i = r.eventRange; r.relevantEvents = t.getRelevantEvents(n.state.eventStore, r.eventRange.instance.instanceId), r.draggingSeg = r.querySeg(e), n.unselect(), n.publiclyTrigger('eventResizeStart', [{ el: r.draggingSeg.el, event: new t.EventApi(n, i.def, i.instance), jsEvent: e.origEvent, view: r.component.view }]) }, r.handleHitUpdate = function (e, n, o) { const a = r.component.calendar; const l = r.relevantEvents; const s = r.hitDragging.initialHit; const c = r.eventRange.instance; let d = null; let g = null; let u = !1; const h = { affectedEvents: l, mutatedEvents: t.createEmptyEventStore(), isEvent: !0, origSeg: r.draggingSeg }; e && (d = (function (e, n, r, o, a) { for (var l = e.component.dateEnv, s = e.dateSpan.range.start, c = n.dateSpan.range.start, d = t.diffDates(s, c, l, e.component.largeUnit), g = {}, u = 0, h = a; u < h.length; u++) { const p = h[u]; const v = p(e, n); if (!1 === v) return null; v && i(g, v) } if (r) { if (l.add(o.start, d) < o.end) return g.startDelta = d, g } else if (l.add(o.end, d) > o.start) return g.endDelta = d, g; return null }(s, e, o.subjectEl.classList.contains('fc-start-resizer'), c.range, a.pluginSystem.hooks.eventResizeJoinTransforms))), d && (g = t.applyMutationToEventStore(l, a.eventUiBases, d, a), h.mutatedEvents = g, r.component.isInteractionValid(h) || (u = !0, d = null, g = null, h.mutatedEvents = null)), g ? a.dispatch({ type: 'SET_EVENT_RESIZE', state: h }) : a.dispatch({ type: 'UNSET_EVENT_RESIZE' }), u ? t.disableCursor() : t.enableCursor(), n || (d && S(s, e) && (d = null), r.validMutation = d, r.mutatedRelevantEvents = g) }, r.handleDragEnd = function (e) { const n = r.component.calendar; const i = r.component.view; const o = r.eventRange.def; const a = r.eventRange.instance; const l = new t.EventApi(n, o, a); const s = r.relevantEvents; const c = r.mutatedRelevantEvents; n.publiclyTrigger('eventResizeStop', [{ el: r.draggingSeg.el, event: l, jsEvent: e.origEvent, view: i }]), r.validMutation ? (n.dispatch({ type: 'MERGE_EVENTS', eventStore: c }), n.publiclyTrigger('eventResize', [{ el: r.draggingSeg.el, startDelta: r.validMutation.startDelta || t.createDuration(0), endDelta: r.validMutation.endDelta || t.createDuration(0), prevEvent: l, event: new t.EventApi(n, c.defs[o.defId], a ? c.instances[a.instanceId] : null), revert: function () { n.dispatch({ type: 'MERGE_EVENTS', eventStore: s }) }, jsEvent: e.origEvent, view: i }])) : n.publiclyTrigger('_noEventResize'), r.draggingSeg = null, r.relevantEvents = null, r.validMutation = null }; const o = n.component; const a = r.dragging = new f(o.el); a.pointer.selector = '.fc-resizer', a.touchScrollAllowed = !1, a.autoScroller.isEnabled = o.opt('dragScroll'); const l = r.hitDragging = new m(r.dragging, t.interactionSettingsToStore(n)); return l.emitter.on('pointerdown', r.handlePointerDown), l.emitter.on('dragstart', r.handleDragStart), l.emitter.on('hitupdate', r.handleHitUpdate), l.emitter.on('dragend', r.handleDragEnd), r } return r(n, e), n.prototype.destroy = function () { this.dragging.destroy() }, n.prototype.querySeg = function (e) { return t.getElSeg(t.elementClosest(e.subjectEl, this.component.fgSegSelector)) }, n }(t.Interaction)); const M = (function () { function e(e) { const n = this; this.isRecentPointerDateSelect = !1, this.onSelect = function (e) { e.jsEvent && (n.isRecentPointerDateSelect = !0) }, this.onDocumentPointerUp = function (e) { const r = n; const i = r.calendar; const o = r.documentPointer; const a = i.state; if (!o.wasTouchScroll) { if (a.dateSelection && !n.isRecentPointerDateSelect) { const l = i.viewOpt('unselectAuto'); const s = i.viewOpt('unselectCancel'); !l || l && t.elementClosest(o.downEl, s) || i.unselect(e) }a.eventSelection && !t.elementClosest(o.downEl, w.SELECTOR) && i.dispatch({ type: 'UNSELECT_EVENT' }) }n.isRecentPointerDateSelect = !1 }, this.calendar = e; const r = this.documentPointer = new s(document); r.shouldIgnoreMove = !0, r.shouldWatchScroll = !1, r.emitter.on('pointerup', this.onDocumentPointerUp), e.on('select', this.onSelect) } return e.prototype.destroy = function () { this.calendar.off('select', this.onSelect), this.documentPointer.destroy() }, e }()); const b = (function () { function e(e, n) { const r = this; this.receivingCalendar = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = function (e) { r.dragMeta = r.buildDragMeta(e.subjectEl) }, this.handleHitUpdate = function (e, n, o) { const a = r.hitDragging.dragging; let l = null; let s = null; let c = !1; const d = { affectedEvents: t.createEmptyEventStore(), mutatedEvents: t.createEmptyEventStore(), isEvent: r.dragMeta.create, origSeg: null }; e && (l = e.component.calendar, r.canDropElOnCalendar(o.subjectEl, l) && (s = (function (e, n, r) { for (var o = i({}, n.leftoverProps), a = 0, l = r.pluginSystem.hooks.externalDefTransforms; a < l.length; a++) { const s = l[a]; i(o, s(e, n)) } const c = t.parseEventDef(o, n.sourceId, e.allDay, r.opt('forceEventDuration') || Boolean(n.duration), r); let d = e.range.start; e.allDay && n.startTime && (d = r.dateEnv.add(d, n.startTime)); const g = n.duration ? r.dateEnv.add(d, n.duration) : r.getDefaultEventEnd(e.allDay, d); const u = t.createEventInstance(c.defId, { start: d, end: g }); return { def: c, instance: u } }(e.dateSpan, r.dragMeta, l)), d.mutatedEvents = t.eventTupleToStore(s), (c = !t.isInteractionValid(d, l)) && (d.mutatedEvents = t.createEmptyEventStore(), s = null))), r.displayDrag(l, d), a.setMirrorIsVisible(n || !s || !document.querySelector('.fc-mirror')), c ? t.disableCursor() : t.enableCursor(), n || (a.setMirrorNeedsRevert(!s), r.receivingCalendar = l, r.droppableEvent = s) }, this.handleDragEnd = function (e) { const n = r; const o = n.receivingCalendar; const a = n.droppableEvent; if (r.clearDrag(), o && a) { const l = r.hitDragging.finalHit; const s = l.component.view; const c = r.dragMeta; const d = i({}, o.buildDatePointApi(l.dateSpan), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: s }); o.publiclyTrigger('drop', [d]), c.create && (o.dispatch({ type: 'MERGE_EVENTS', eventStore: t.eventTupleToStore(a) }), e.isTouch && o.dispatch({ type: 'SELECT_EVENT', eventInstanceId: a.instance.instanceId }), o.publiclyTrigger('eventReceive', [{ draggedEl: e.subjectEl, event: new t.EventApi(o, a.def, a.instance), view: s }])) }r.receivingCalendar = null, r.droppableEvent = null }; const o = this.hitDragging = new m(e, t.interactionSettingsStore); o.requireInitial = !1, o.emitter.on('dragstart', this.handleDragStart), o.emitter.on('hitupdate', this.handleHitUpdate), o.emitter.on('dragend', this.handleDragEnd), this.suppliedDragMeta = n } return e.prototype.buildDragMeta = function (e) { return typeof this.suppliedDragMeta === 'object' ? t.parseDragMeta(this.suppliedDragMeta) : typeof this.suppliedDragMeta === 'function' ? t.parseDragMeta(this.suppliedDragMeta(e)) : (n = (function (e, n) { const r = t.config.dataAttrPrefix; const i = (r ? r + '-' : '') + n; return e.getAttribute('data-' + i) || '' }(e, 'event')), r = n ? JSON.parse(n) : { create: !1 }, t.parseDragMeta(r)); let n, r }, e.prototype.displayDrag = function (e, t) { const n = this.receivingCalendar; n && n !== e && n.dispatch({ type: 'UNSET_EVENT_DRAG' }), e && e.dispatch({ type: 'SET_EVENT_DRAG', state: t }) }, e.prototype.clearDrag = function () { this.receivingCalendar && this.receivingCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' }) }, e.prototype.canDropElOnCalendar = function (e, n) { const r = n.opt('dropAccept'); return typeof r === 'function' ? r(e) : typeof r !== 'string' || !r || Boolean(t.elementMatches(e, r)) }, e }()); t.config.dataAttrPrefix = ''; const C = (function () { function e(e, n) { const r = this; void 0 === n && (n = {}), this.handlePointerDown = function (e) { const n = r.dragging; const i = r.settings; const o = i.minDistance; const a = i.longPressDelay; n.minDistance = o != null ? o : e.isTouch ? 0 : t.globalDefaults.eventDragMinDistance, n.delay = e.isTouch ? a != null ? a : t.globalDefaults.longPressDelay : 0 }, this.handleDragStart = function (e) { e.isTouch && r.dragging.delay && e.subjectEl.classList.contains('fc-event') && r.dragging.mirror.getMirrorEl().classList.add('fc-selected') }, this.settings = n; const i = this.dragging = new f(e); i.touchScrollAllowed = !1, n.itemSelector != null && (i.pointer.selector = n.itemSelector), n.appendTo != null && (i.mirror.parentNode = n.appendTo), i.emitter.on('pointerdown', this.handlePointerDown), i.emitter.on('dragstart', this.handleDragStart), new b(i, n.eventData) } return e.prototype.destroy = function () { this.dragging.destroy() }, e }()); const R = (function (e) { function t(t) { const n = e.call(this, t) || this; n.shouldIgnoreMove = !1, n.mirrorSelector = '', n.currentMirrorEl = null, n.handlePointerDown = function (e) { n.emitter.trigger('pointerdown', e), n.shouldIgnoreMove || n.emitter.trigger('dragstart', e) }, n.handlePointerMove = function (e) { n.shouldIgnoreMove || n.emitter.trigger('dragmove', e) }, n.handlePointerUp = function (e) { n.emitter.trigger('pointerup', e), n.shouldIgnoreMove || n.emitter.trigger('dragend', e) }; const r = n.pointer = new s(t); return r.emitter.on('pointerdown', n.handlePointerDown), r.emitter.on('pointermove', n.handlePointerMove), r.emitter.on('pointerup', n.handlePointerUp), n } return r(t, e), t.prototype.destroy = function () { this.pointer.destroy() }, t.prototype.setIgnoreMove = function (e) { this.shouldIgnoreMove = e }, t.prototype.setMirrorIsVisible = function (e) { if (e) this.currentMirrorEl && (this.currentMirrorEl.style.visibility = '', this.currentMirrorEl = null); else { const t = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null; t && (this.currentMirrorEl = t, t.style.visibility = 'hidden') } }, t }(t.ElementDragging)); const I = (function () { function e(e, t) { let n = document; e === document || e instanceof Element ? (n = e, t = t || {}) : t = e || {}; const r = this.dragging = new R(n); typeof t.itemSelector === 'string' ? r.pointer.selector = t.itemSelector : n === document && (r.pointer.selector = '[data-event]'), typeof t.mirrorSelector === 'string' && (r.mirrorSelector = t.mirrorSelector), new b(r, t.eventData) } return e.prototype.destroy = function () { this.dragging.destroy() }, e }()); const P = t.createPlugin({ componentInteractions: [y, D, w, T], calendarInteractions: [M], elementDraggingImpl: f }); e.Draggable = C, e.FeaturefulElementDragging = f, e.PointerDragging = s, e.ThirdPartyDraggable = I, e.default = P, Object.defineProperty(e, '__esModule', { value: !0 }) }))